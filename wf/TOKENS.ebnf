(*
	This file describes in EBNF form, how `wf` lexes a file into tokens.
*)

digit ::= ? ASCII digits 0-9 ?;
letter ::= ? ASCII uppercase/lowercase letters ?;
any_character ::= ? any character ?;

(* Cross-platform newline - \n, \r\n, \r *)
newline ::= '\n' / ('\r', ['\n']);
whitespace ::= ' ' / '\t';

comment_short ::= '--', { any_character - (newline) };
(* Long comments can be defined with 3 *or more* hyphens. *)
comment_long_3 ::=  '---', {any_character - '---'}, '---';
comment ::= ? comment_long_6/5/4/etc... ? / comment_long_3 / comment_short;

name_ticked ::= '`', { any_character - '`' }, '`';
name_unticked ::= { '_' / letter / (digit, [ '.', digit]) };
name ::= name_ticked / name_unticked;

insert_sequence ::= '\\', ('n' / 't' / '\\' / '"');
string_standard ::= '"', { insert_sequence / (any_character - '"') }, '"';
(* Raw strings can be defined with 3 *or more* quotes. *)
string_raw_3 ::=  '"""', {any_character - '"""'}, '"""';
string ::= ? string_raw_6/5/4/etc... ? / string_raw_3 / string_standard;

keyword ::= 'loop' / 'and' / 'let' / 'or' / 'fn';

notation ::=
	'...' /
	'//' / '!=' / '<=' / '>=' / '->' / '=>' /
	'[' / ']' / '(' / ')' / ',' / '.' / '+' / '-' / '*' / '/' / '^' / '=' / '!' / '<' / '>';